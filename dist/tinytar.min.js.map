{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///tinytar.min.js","webpack:///webpack/bootstrap 3b68b598dba067bc70d9","webpack:///./index.js","webpack:///./lib/utils.js","webpack:///./lib/constants.js","webpack:///./lib/tar.js","webpack:///./lib/types.js","webpack:///./lib/untar.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","utils","constants","tar","untar","extend","isUndefined","value","undefined","isString","Object","prototype","toString","isDateTime","isObject","isFunction","isLength","MAX_SAFE_INTEGER","isArray","isArrayLike","length","isArrayBuffer","map","array","iteratee","Array","find","result","every","item","index","found","target","assign","apply","arguments","toUint8Array","i","Uint8Array","charCodeAt","buffer","NULL_CHAR","TMAGIC","OLDGNU_MAGIC","REGTYPE","LNKTYPE","SYMTYPE","CHRTYPE","BLKTYPE","DIRTYPE","FIFOTYPE","CONTTYPE","TSUID","parseInt","TSGID","TSVTX","TUREAD","TUWRITE","TUEXEC","TGREAD","TGWRITE","TGEXEC","TOREAD","TOWRITE","TOEXEC","TPERMALL","TPERMMASK","headerSize","file","types","recordSize","dataSize","Math","ceil","data","allocateBuffer","files","totalSize","forEach","writeHeader","offset","currentOffset","posixHeader","field","checksum","calculateChecksum","formatTarNumber","writeData","set","fixUstarMagic","chars","split","join","formatTarString","substr","defaultValue","formatTarDateTime","floor","isFinite","Date","parseTarString","bytes","returnUnprocessed","String","fromCharCode","indexOf","parseTarNumber","replace","parseTarDateTime","skipChecksum","from","to","min","effectiveHeaderSize","skipFrom","skipTo","whitespace","byte","defaultFileMode","defaultUid","defaultGid","slice","mode","header","last","size","isEndOfFile","readHeader","options","checkFileSize","Error","messages","unexpectedEndOfFile","type","checkHeader","error","fileCorrupted","checkChecksum","checksumCheckFailed","readData","extractData","createFile","name","excludeFields","isOldGNUFormat","ustar","defaultOptions","push"],"mappings":"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","file":"tinytar.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"tinyTar\"] = factory();\n\telse\n\t\troot[\"tinyTar\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"tinyTar\"] = factory();\n\telse\n\t\troot[\"tinyTar\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t// http://www.gnu.org/software/tar/manual/html_node/Standard.html\n\t\n\tvar utils = __webpack_require__(1);\n\tvar constants = __webpack_require__(2);\n\tvar tar = __webpack_require__(3);\n\tvar untar = __webpack_require__(5);\n\t\n\tutils.extend(module.exports, tar, untar, constants);\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\n\t'use strict';\n\t\n\tvar MAX_SAFE_INTEGER = 9007199254740991;\n\t\n\tvar undefined = (function(undefined) {\n\t  return undefined;\n\t})();\n\t\n\tfunction isUndefined(value) {\n\t  return value === undefined;\n\t}\n\t\n\tfunction isString(value) {\n\t  return (typeof value == 'string') ||\n\t    (Object.prototype.toString.call(value) == '[object String]');\n\t}\n\t\n\tfunction isDateTime(value) {\n\t  return (Object.prototype.toString.call(value) == '[object Date]');\n\t}\n\t\n\tfunction isObject(value) {\n\t  return (value !== null) && (typeof value == 'object');\n\t}\n\t\n\tfunction isFunction(value) {\n\t  return typeof value == 'function';\n\t}\n\t\n\tfunction isLength(value) {\n\t  return (typeof value == 'number') &&\n\t    (value > -1) && (value % 1 == 0) &&\n\t    (value <= MAX_SAFE_INTEGER);\n\t}\n\t\n\tfunction isArray(value) {\n\t  return Object.prototype.toString.call(value) == '[object Array]';\n\t}\n\t\n\tfunction isArrayLike(value) {\n\t  return isObject(value) && !isFunction(value) && isLength(value.length);\n\t}\n\t\n\tfunction isArrayBuffer(value) {\n\t  return Object.prototype.toString.call(value) == '[object ArrayBuffer]';\n\t}\n\t\n\tfunction map(array, iteratee) {\n\t  return Array.prototype.map.call(array, iteratee);\n\t}\n\t\n\tfunction find(array, iteratee) {\n\t  var result = undefined;\n\t\n\t  if (isFunction(iteratee)) {\n\t    Array.prototype.every.call(array, function(item, index, array) {\n\t      var found = iteratee(item, index, array);\n\t      if (found) {\n\t        result = item;\n\t      }\n\t      return !found;  // continue if not found\n\t    });\n\t  }\n\t\n\t  return result;\n\t}\n\t\n\tfunction extend(target /* ...sources */) {\n\t  return Object.assign.apply(null, arguments);\n\t}\n\t\n\tfunction toUint8Array(value) {\n\t  var i;\n\t  var length;\n\t  var result;\n\t\n\t  if (isString(value)) {\n\t    length = value.length;\n\t    result = new Uint8Array(length);\n\t    for (i = 0; i < length; i++) {\n\t      result[i] = value.charCodeAt(i) & 0xFF;\n\t    }\n\t    return result;\n\t  }\n\t\n\t  if (isArrayBuffer(value)) {\n\t    return new Uint8Array(value);\n\t  }\n\t\n\t  if (isObject(value) && isArrayBuffer(value.buffer)) {\n\t    return new Uint8Array(value.buffer);\n\t  }\n\t\n\t  if (isArrayLike(value)) {\n\t    return new Uint8Array(value);\n\t  }\n\t\n\t  if (isObject(value) && isFunction(value.toString)) {\n\t    return toUint8Array(value.toString());\n\t  }\n\t\n\t  return new Uint8Array();\n\t}\n\t\n\tmodule.exports.MAX_SAFE_INTEGER = MAX_SAFE_INTEGER;\n\t\n\tmodule.exports.isUndefined = isUndefined;\n\tmodule.exports.isString = isString;\n\tmodule.exports.isObject = isObject;\n\tmodule.exports.isDateTime = isDateTime;\n\tmodule.exports.isFunction = isFunction;\n\tmodule.exports.isArray = isArray;\n\tmodule.exports.isArrayLike = isArrayLike;\n\tmodule.exports.isArrayBuffer = isArrayBuffer;\n\tmodule.exports.map = map;\n\tmodule.exports.find = find;\n\tmodule.exports.extend = extend;\n\tmodule.exports.toUint8Array = toUint8Array;\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports) {\n\n\t'use strict';\n\t\n\tvar NULL_CHAR = '\\u0000';\n\t\n\tmodule.exports = {\n\t  /* eslint-disable key-spacing */\n\t\n\t  NULL_CHAR: NULL_CHAR,\n\t\n\t  TMAGIC: 'ustar' + NULL_CHAR + '00',   // 'ustar', NULL, '00'\n\t  OLDGNU_MAGIC: 'ustar  ' + NULL_CHAR,  // 'ustar  ', NULL\n\t\n\t  // Values used in typeflag field.\n\t  REGTYPE:  0,  // regular file\n\t  LNKTYPE:  1,  // link\n\t  SYMTYPE:  2,  // reserved\n\t  CHRTYPE:  3,  // character special\n\t  BLKTYPE:  4,  // block special\n\t  DIRTYPE:  5,  // directory\n\t  FIFOTYPE: 6,  // FIFO special\n\t  CONTTYPE: 7,  // reserved\n\t\n\t  // Bits used in the mode field, values in octal.\n\t  TSUID: parseInt('4000', 8),  // set UID on execution\n\t  TSGID: parseInt('2000', 8),  // set GID on execution\n\t  TSVTX: parseInt('1000', 8),  // reserved\n\t\n\t  // file permissions\n\t  TUREAD:  parseInt('0400', 8),  // read by owner\n\t  TUWRITE: parseInt('0200', 8),  // write by owner\n\t  TUEXEC:  parseInt('0100', 8),  // execute/search by owner\n\t  TGREAD:  parseInt('0040', 8),  // read by group\n\t  TGWRITE: parseInt('0020', 8),  // write by group\n\t  TGEXEC:  parseInt('0010', 8),  // execute/search by group\n\t  TOREAD:  parseInt('0004', 8),  // read by other\n\t  TOWRITE: parseInt('0002', 8),  // write by other\n\t  TOEXEC:  parseInt('0001', 8),   // execute/search by other\n\t\n\t  TPERMALL:  parseInt('0777', 8),   // rwxrwxrwx\n\t  TPERMMASK: parseInt('0777', 8)    // permissions bitmask\n\t\n\t  /* eslint-enable key-spacing */\n\t};\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar constants = __webpack_require__(2);\n\tvar utils = __webpack_require__(1);\n\tvar types = __webpack_require__(4);\n\t\n\tfunction headerSize(file) {\n\t  // header has fixed size\n\t  return types.recordSize;\n\t}\n\t\n\tfunction dataSize(file) {\n\t  // align to record boundary\n\t  return Math.ceil(file.data.length / types.recordSize) * types.recordSize;\n\t}\n\t\n\tfunction allocateBuffer(files) {\n\t  var totalSize = 0;\n\t\n\t  // Calculate space that will be used by each file\n\t  files.forEach(function(file) {\n\t    totalSize += headerSize(file) + dataSize(file);\n\t  });\n\t\n\t  // TAR must end with two empty records\n\t  totalSize += types.recordSize * 2;\n\t\n\t  // Array SHOULD be initialized with zeros:\n\t  // from TypedArray constructor docs:\n\t  // > When creating a TypedArray instance (i.e. instance of Int8Array\n\t  // > or similar), an array buffer is created internally\n\t  // from ArrayBuffer constructor docs:\n\t  // > A new ArrayBuffer object of the specified size.\n\t  // > Its contents are initialized to 0.\n\t  return new Uint8Array(totalSize);\n\t}\n\t\n\tfunction writeHeader(buffer, file, offset) {\n\t  offset = parseInt(offset) || 0;\n\t\n\t  var currentOffset = offset;\n\t  types.posixHeader.forEach(function(field) {\n\t    var value = field[3](file, field);\n\t    var length = value.length;\n\t    for (var i = 0; i < length; i += 1) {\n\t      buffer[currentOffset + i] = value.charCodeAt(i) & 0xFF;\n\t    }\n\t    currentOffset += field[1];  // move to the next field\n\t  });\n\t\n\t  var field = utils.find(types.posixHeader, function(field) {\n\t    return field[0] == 'checksum';\n\t  });\n\t\n\t  if (field) {\n\t    // Patch checksum field\n\t    var checksum = types.calculateChecksum(buffer, offset, true);\n\t    var value = types.formatTarNumber(checksum, field[1] - 2) +\n\t      constants.NULL_CHAR + ' ';\n\t    currentOffset = offset + field[2];\n\t    for (var i = 0; i < value.length; i += 1) {\n\t      // put bytes\n\t      buffer[currentOffset] = value.charCodeAt(i) & 0xFF;\n\t      currentOffset++;\n\t    }\n\t  }\n\t\n\t  return offset + headerSize(file);\n\t}\n\t\n\tfunction writeData(buffer, file, offset) {\n\t  offset = parseInt(offset, 10) || 0;\n\t  buffer.set(file.data, offset);\n\t  return offset + dataSize(file);\n\t}\n\t\n\tfunction tar(files) {\n\t  files = utils.map(files, function(file) {\n\t    return utils.extend({}, file, {\n\t      data: utils.toUint8Array(file.data)\n\t    });\n\t  });\n\t\n\t  var buffer = allocateBuffer(files);\n\t\n\t  var offset = 0;\n\t  files.forEach(function(file) {\n\t    offset = writeHeader(buffer, file, offset);\n\t    offset = writeData(buffer, file, offset);\n\t  });\n\t\n\t  return buffer;\n\t}\n\t\n\tmodule.exports.tar = tar;\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar utils = __webpack_require__(1);\n\tvar constants = __webpack_require__(2);\n\t\n\tvar recordSize = 512;\n\tvar defaultFileMode = constants.TPERMALL;  // rwxrwxrwx\n\tvar defaultUid = 0;  // root\n\tvar defaultGid = 0;  // root\n\t\n\t/*\n\t struct posix_header {           // byte offset\n\t char name[100];               //   0\n\t char mode[8];                 // 100\n\t char uid[8];                  // 108\n\t char gid[8];                  // 116\n\t char size[12];                // 124\n\t char mtime[12];               // 136\n\t char chksum[8];               // 148\n\t char typeflag;                // 156\n\t char linkname[100];           // 157\n\t char magic[6];                // 257\n\t char version[2];              // 263\n\t char uname[32];               // 265\n\t char gname[32];               // 297\n\t char devmajor[8];             // 329\n\t char devminor[8];             // 337\n\t char prefix[131];             // 345\n\t char atime[12];               // 476\n\t char ctime[12];               // 488\n\t };\n\t */\n\t\n\tvar posixHeader = [\n\t  // <field name>, <size>, <offset>, <used>, <format>, <parse>, [ <check> ]\n\t  ['name', 100, 0, function(file, field) {\n\t    return formatTarString(file[field[0]], field[1]);\n\t  }, function(buffer, offset, field) {\n\t    return parseTarString(buffer.slice(offset, offset + field[1]));\n\t  }],\n\t  ['mode', 8, 100, function(file, field) {\n\t    var mode = file[field[0]] || defaultFileMode;\n\t    mode = mode & constants.TPERMMASK;\n\t    return formatTarNumber(mode, field[1], defaultFileMode);\n\t  }, function(buffer, offset, field) {\n\t    var result = parseTarNumber(buffer.slice(offset, offset + field[1]));\n\t    result &= constants.TPERMMASK;\n\t    return result;\n\t  }],\n\t  ['uid', 8, 108, function(file, field) {\n\t    return formatTarNumber(file[field[0]], field[1], defaultUid);\n\t  }, function(buffer, offset, field) {\n\t    return parseTarNumber(buffer.slice(offset, offset + field[1]));\n\t  }],\n\t  ['gid', 8, 116, function(file, field) {\n\t    return formatTarNumber(file[field[0]], field[1], defaultGid);\n\t  }, function(buffer, offset, field) {\n\t    return parseTarNumber(buffer.slice(offset, offset + field[1]));\n\t  }],\n\t  ['size', 12, 124, function(file, field) {\n\t    return formatTarNumber(file.data.length, field[1]);\n\t  }, function(buffer, offset, field) {\n\t    return parseTarNumber(buffer.slice(offset, offset + field[1]));\n\t  }],\n\t  ['modifyTime', 12, 136, function(file, field) {\n\t    return formatTarDateTime(file[field[0]], field[1]);\n\t  }, function(buffer, offset, field) {\n\t    return parseTarDateTime(buffer.slice(offset, offset + field[1]));\n\t  }],\n\t  ['checksum', 8, 148, function(file, field) {\n\t    return '        ';  // placeholder\n\t  }, function(buffer, offset, field) {\n\t    return parseTarNumber(buffer.slice(offset, offset + field[1]));\n\t  }],\n\t  ['type', 1, 156, function(file, field) {\n\t    // get last octal digit; 0 - regular file\n\t    return '' + ((parseInt(file[field[0]], 10) || 0) % 8);\n\t  }, function(buffer, offset, field) {\n\t    return (parseInt(String.fromCharCode(buffer[offset]), 10) || 0) % 8;\n\t  }],\n\t  ['linkName', 100, 157, function(file, field) {\n\t    return '';  // only regular files are supported\n\t  }, function(buffer, offset, field) {\n\t    return parseTarString(buffer.slice(offset, offset + field[1]));\n\t  }],\n\t  ['ustar', 8, 257, function(file, field) {\n\t    return constants.TMAGIC;  // magic + version\n\t  }, function(buffer, offset, field) {\n\t    return fixUstarMagic(\n\t      parseTarString(buffer.slice(offset, offset + field[1]), true)\n\t    );\n\t  }, function(file, field) {\n\t    return (file[field[0]] == constants.TMAGIC) ||\n\t      (file[field[0]] == constants.OLDGNU_MAGIC);\n\t  }],\n\t  ['owner', 32, 265, function(file, field) {\n\t    return formatTarString(file[field[0]], field[1]);\n\t  }, function(buffer, offset, field) {\n\t    return parseTarString(buffer.slice(offset, offset + field[1]));\n\t  }],\n\t  ['group', 32, 297, function(file, field) {\n\t    return formatTarString(file[field[0]], field[1]);\n\t  }, function(buffer, offset, field) {\n\t    return parseTarString(buffer.slice(offset, offset + field[1]));\n\t  }],\n\t  ['majorNumber', 8, 329, function(file, field) {\n\t    return '';  // only regular files are supported\n\t  }, function(buffer, offset, field) {\n\t    return parseTarNumber(buffer.slice(offset, offset + field[1]));\n\t  }],\n\t  ['minorNumber', 8, 337, function(file, field) {\n\t    return '';  // only regular files are supported\n\t  }, function(buffer, offset, field) {\n\t    return parseTarNumber(buffer.slice(offset, offset + field[1]));\n\t  }],\n\t  ['prefix', 131, 345, function(file, field) {\n\t    return formatTarString(file[field[0]], field[1]);\n\t  }, function(buffer, offset, field) {\n\t    return parseTarString(buffer.slice(offset, offset + field[1]));\n\t  }],\n\t  ['accessTime', 12, 476, function(file, field) {\n\t    return formatTarDateTime(file[field[0]], field[1]);\n\t  }, function(buffer, offset, field) {\n\t    return parseTarDateTime(buffer.slice(offset, offset + field[1]));\n\t  }],\n\t  ['createTime', 12, 488, function(file, field) {\n\t    return formatTarDateTime(file[field[0]], field[1]);\n\t  }, function(buffer, offset, field) {\n\t    return parseTarDateTime(buffer.slice(offset, offset + field[1]));\n\t  }]\n\t];\n\t\n\tvar effectiveHeaderSize = (function(header) {\n\t  var last = header[header.length - 1];\n\t  return last[2] + last[1];  // offset + size\n\t})(posixHeader);\n\t\n\tfunction fixUstarMagic(value) {\n\t  if (value.length == 8) {\n\t    var chars = value.split('');\n\t\n\t    if (chars[5] == constants.NULL_CHAR) {\n\t      // TMAGIC ?\n\t      if ((chars[6] == ' ') || (chars[6] == constants.NULL_CHAR)) {\n\t        chars[6] = '0';\n\t      }\n\t      if ((chars[7] == ' ') || (chars[7] == constants.NULL_CHAR)) {\n\t        chars[7] = '0';\n\t      }\n\t      chars = chars.join('');\n\t      return chars == constants.TMAGIC ? chars : value;\n\t    } else if (chars[7] == constants.NULL_CHAR) {\n\t      // OLDGNU_MAGIC ?\n\t      if (chars[5] == constants.NULL_CHAR) {\n\t        chars[5] = ' ';\n\t      }\n\t      if (chars[6] == constants.NULL_CHAR) {\n\t        chars[6] = ' ';\n\t      }\n\t      return chars == constants.OLDGNU_MAGIC ? chars : value;\n\t    }\n\t  }\n\t  return value;\n\t}\n\t\n\tfunction formatTarString(value, length) {\n\t  length -= 1;  // preserve space for trailing null-char\n\t  if (utils.isUndefined(value)) {\n\t    value = '';\n\t  }\n\t  value = ('' + value).substr(0, length);\n\t  return value + constants.NULL_CHAR;\n\t}\n\t\n\tfunction formatTarNumber(value, length, defaultValue) {\n\t  defaultValue = parseInt(defaultValue) || 0;\n\t  length -= 1;  // preserve space for trailing null-char\n\t  value = (parseInt(value) || defaultValue)\n\t    .toString(8).substr(-length, length);\n\t  while (value.length < length) {\n\t    value = '0' + value;\n\t  }\n\t  return value + constants.NULL_CHAR;\n\t}\n\t\n\tfunction formatTarDateTime(value, length) {\n\t  if (utils.isDateTime(value)) {\n\t    value = Math.floor(1 * value / 1000);\n\t  } else {\n\t    value = parseInt(value, 10);\n\t    if (isFinite(value)) {\n\t      if (value <= 0) {\n\t        return '';\n\t      }\n\t    } else {\n\t      value = Math.floor(1 * new Date() / 1000);\n\t    }\n\t  }\n\t  return formatTarNumber(value, length, 0);\n\t}\n\t\n\tfunction parseTarString(bytes, returnUnprocessed) {\n\t  var result = String.fromCharCode.apply(null, bytes);\n\t  if (returnUnprocessed) {\n\t    return result;\n\t  }\n\t  var index = result.indexOf(constants.NULL_CHAR);\n\t  return index >= 0 ? result.substr(0, index) : result;\n\t}\n\t\n\tfunction parseTarNumber(bytes) {\n\t  var result = String.fromCharCode.apply(null, bytes);\n\t  return parseInt(result.replace(/^0+$/g, ''), 8) || 0;\n\t}\n\t\n\tfunction parseTarDateTime(bytes) {\n\t  if ((bytes.length == 0) || (bytes[0] == 0)) {\n\t    return null;\n\t  }\n\t  return new Date(1000 * parseTarNumber(bytes));\n\t}\n\t\n\tfunction calculateChecksum(buffer, offset, skipChecksum) {\n\t  var from = parseInt(offset, 10) || 0;\n\t  var to = Math.min(from + effectiveHeaderSize, buffer.length);\n\t  var result = 0;\n\t\n\t  // When calculating checksum, `checksum` field should be\n\t  // threat as filled with space char (byte 32)\n\t  var skipFrom = 0;\n\t  var skipTo = 0;\n\t  if (skipChecksum) {\n\t    posixHeader.every(function(field) {\n\t      if (field[0] == 'checksum') {\n\t        skipFrom = from + field[2];\n\t        skipTo = skipFrom + field[1];\n\t        return false;\n\t      }\n\t      return true;\n\t    });\n\t  }\n\t\n\t  var whitespace = ' '.charCodeAt(0);\n\t  for (var i = from; i < to; i++) {\n\t    // 262144 = 8^6 - 6 octal digits - maximum possible value for checksum;\n\t    // wrap to avoid numeric overflow\n\t    var byte = (i >= skipFrom) && (i < skipTo) ? whitespace : buffer[i];\n\t    result = (result + byte) % 262144;\n\t  }\n\t  return result;\n\t}\n\t\n\tmodule.exports.recordSize = recordSize;\n\tmodule.exports.defaultFileMode = defaultFileMode;\n\tmodule.exports.defaultUid = defaultUid;\n\tmodule.exports.defaultGid = defaultGid;\n\tmodule.exports.posixHeader = posixHeader;\n\tmodule.exports.effectiveHeaderSize = effectiveHeaderSize;\n\t\n\tmodule.exports.calculateChecksum = calculateChecksum;\n\tmodule.exports.formatTarString = formatTarString;\n\tmodule.exports.formatTarNumber = formatTarNumber;\n\tmodule.exports.formatTarDateTime = formatTarDateTime;\n\tmodule.exports.parseTarString = parseTarString;\n\tmodule.exports.parseTarNumber = parseTarNumber;\n\tmodule.exports.parseTarDateTime = parseTarDateTime;\n\t\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar constants = __webpack_require__(2);\n\tvar utils = __webpack_require__(1);\n\tvar types = __webpack_require__(4);\n\t\n\tvar defaultOptions = {\n\t  extractData: true,\n\t  checkHeader: true,\n\t  checkChecksum: true,\n\t  checkFileSize: true\n\t};\n\t\n\tvar excludeFields = {\n\t  size: true,\n\t  checksum: true,\n\t  ustar: true\n\t};\n\t\n\tvar messages = {\n\t  unexpectedEndOfFile: 'Unexpected end of file.',\n\t  fileCorrupted: 'File is corrupted.',\n\t  checksumCheckFailed: 'Checksum check failed.'\n\t};\n\t\n\tfunction headerSize(header) {\n\t  // header has fixed size\n\t  return types.recordSize;\n\t}\n\t\n\tfunction dataSize(size) {\n\t  // align to record boundary\n\t  return Math.ceil(size / types.recordSize) * types.recordSize;\n\t}\n\t\n\tfunction isEndOfFile(buffer, offset) {\n\t  var from = offset;\n\t  var to = Math.min(buffer.length, offset + types.recordSize * 2);\n\t  for (var i = from; i < to; i++) {\n\t    if (buffer[i] != 0) {\n\t      return false;\n\t    }\n\t  }\n\t  return true;\n\t}\n\t\n\tfunction readHeader(buffer, offset, options) {\n\t  if (buffer.length - offset < types.recordSize) {\n\t    if (options.checkFileSize) {\n\t      throw new Error(messages.unexpectedEndOfFile);\n\t    }\n\t    return null;\n\t  }\n\t\n\t  offset = parseInt(offset) || 0;\n\t\n\t  var result = {};\n\t  var currentOffset = offset;\n\t  types.posixHeader.forEach(function(field) {\n\t    result[field[0]] = field[4](buffer, currentOffset, field);\n\t    currentOffset += field[1];\n\t  });\n\t\n\t  if (result.type != 0) {  // only regular files can have data\n\t    result.size = 0;\n\t  }\n\t\n\t  if (options.checkHeader) {\n\t    types.posixHeader.forEach(function(field) {\n\t      if (utils.isFunction(field[5]) && !field[5](result, field)) {\n\t        var error = new Error(messages.fileCorrupted);\n\t        error.data = {\n\t          offset: offset + field[2],\n\t          field: field[0]\n\t        };\n\t        throw error;\n\t      }\n\t    });\n\t  }\n\t\n\t  if (options.checkChecksum) {\n\t    var checksum = types.calculateChecksum(buffer, offset, true);\n\t    if (checksum != result.checksum) {\n\t      var error = new Error(messages.checksumCheckFailed);\n\t      error.data = {\n\t        offset: offset,\n\t        header: result,\n\t        checksum: checksum\n\t      };\n\t      throw error;\n\t    }\n\t  }\n\t\n\t  return result;\n\t}\n\t\n\tfunction readData(buffer, offset, header, options) {\n\t  if (!options.extractData) {\n\t    return null;\n\t  }\n\t\n\t  if (header.size <= 0) {\n\t    return new Uint8Array();\n\t  }\n\t  return buffer.slice(offset, offset + header.size);\n\t}\n\t\n\tfunction createFile(header, data) {\n\t  var result = {};\n\t  types.posixHeader.forEach(function(field) {\n\t    var name = field[0];\n\t    if (!excludeFields[name]) {\n\t      result[name] = header[name];\n\t    }\n\t  });\n\t\n\t  result.isOldGNUFormat = header.ustar == constants.OLDGNU_MAGIC;\n\t\n\t  if (data) {\n\t    result.data = data;\n\t  }\n\t\n\t  return result;\n\t}\n\t\n\tfunction untar(buffer, options) {\n\t  options = utils.extend({}, defaultOptions, options);\n\t\n\t  var result = [];\n\t  var offset = 0;\n\t  var size = buffer.length;\n\t\n\t  while (size - offset >= types.recordSize) {\n\t    buffer = utils.toUint8Array(buffer);\n\t    var header = readHeader(buffer, offset, options);\n\t    if (!header) {\n\t      break;\n\t    }\n\t    offset += headerSize(header);\n\t\n\t    var data = readData(buffer, offset, header, options);\n\t    result.push(createFile(header, data));\n\t    offset += dataSize(header.size);\n\t\n\t    if (isEndOfFile(buffer, offset)) {\n\t      break;\n\t    }\n\t  }\n\t\n\t  return result;\n\t}\n\t\n\tmodule.exports.untar = untar;\n\n\n/***/ })\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// tinytar.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 3b68b598dba067bc70d9","'use strict';\n\n// http://www.gnu.org/software/tar/manual/html_node/Standard.html\n\nvar utils = require('./lib/utils');\nvar constants = require('./lib/constants');\nvar tar = require('./lib/tar');\nvar untar = require('./lib/untar');\n\nutils.extend(module.exports, tar, untar, constants);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./index.js\n// module id = 0\n// module chunks = 0","'use strict';\n\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\nvar undefined = (function(undefined) {\n  return undefined;\n})();\n\nfunction isUndefined(value) {\n  return value === undefined;\n}\n\nfunction isString(value) {\n  return (typeof value == 'string') ||\n    (Object.prototype.toString.call(value) == '[object String]');\n}\n\nfunction isDateTime(value) {\n  return (Object.prototype.toString.call(value) == '[object Date]');\n}\n\nfunction isObject(value) {\n  return (value !== null) && (typeof value == 'object');\n}\n\nfunction isFunction(value) {\n  return typeof value == 'function';\n}\n\nfunction isLength(value) {\n  return (typeof value == 'number') &&\n    (value > -1) && (value % 1 == 0) &&\n    (value <= MAX_SAFE_INTEGER);\n}\n\nfunction isArray(value) {\n  return Object.prototype.toString.call(value) == '[object Array]';\n}\n\nfunction isArrayLike(value) {\n  return isObject(value) && !isFunction(value) && isLength(value.length);\n}\n\nfunction isArrayBuffer(value) {\n  return Object.prototype.toString.call(value) == '[object ArrayBuffer]';\n}\n\nfunction map(array, iteratee) {\n  return Array.prototype.map.call(array, iteratee);\n}\n\nfunction find(array, iteratee) {\n  var result = undefined;\n\n  if (isFunction(iteratee)) {\n    Array.prototype.every.call(array, function(item, index, array) {\n      var found = iteratee(item, index, array);\n      if (found) {\n        result = item;\n      }\n      return !found;  // continue if not found\n    });\n  }\n\n  return result;\n}\n\nfunction extend(target /* ...sources */) {\n  return Object.assign.apply(null, arguments);\n}\n\nfunction toUint8Array(value) {\n  var i;\n  var length;\n  var result;\n\n  if (isString(value)) {\n    length = value.length;\n    result = new Uint8Array(length);\n    for (i = 0; i < length; i++) {\n      result[i] = value.charCodeAt(i) & 0xFF;\n    }\n    return result;\n  }\n\n  if (isArrayBuffer(value)) {\n    return new Uint8Array(value);\n  }\n\n  if (isObject(value) && isArrayBuffer(value.buffer)) {\n    return new Uint8Array(value.buffer);\n  }\n\n  if (isArrayLike(value)) {\n    return new Uint8Array(value);\n  }\n\n  if (isObject(value) && isFunction(value.toString)) {\n    return toUint8Array(value.toString());\n  }\n\n  return new Uint8Array();\n}\n\nmodule.exports.MAX_SAFE_INTEGER = MAX_SAFE_INTEGER;\n\nmodule.exports.isUndefined = isUndefined;\nmodule.exports.isString = isString;\nmodule.exports.isObject = isObject;\nmodule.exports.isDateTime = isDateTime;\nmodule.exports.isFunction = isFunction;\nmodule.exports.isArray = isArray;\nmodule.exports.isArrayLike = isArrayLike;\nmodule.exports.isArrayBuffer = isArrayBuffer;\nmodule.exports.map = map;\nmodule.exports.find = find;\nmodule.exports.extend = extend;\nmodule.exports.toUint8Array = toUint8Array;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/utils.js\n// module id = 1\n// module chunks = 0","'use strict';\n\nvar NULL_CHAR = '\\u0000';\n\nmodule.exports = {\n  /* eslint-disable key-spacing */\n\n  NULL_CHAR: NULL_CHAR,\n\n  TMAGIC: 'ustar' + NULL_CHAR + '00',   // 'ustar', NULL, '00'\n  OLDGNU_MAGIC: 'ustar  ' + NULL_CHAR,  // 'ustar  ', NULL\n\n  // Values used in typeflag field.\n  REGTYPE:  0,  // regular file\n  LNKTYPE:  1,  // link\n  SYMTYPE:  2,  // reserved\n  CHRTYPE:  3,  // character special\n  BLKTYPE:  4,  // block special\n  DIRTYPE:  5,  // directory\n  FIFOTYPE: 6,  // FIFO special\n  CONTTYPE: 7,  // reserved\n\n  // Bits used in the mode field, values in octal.\n  TSUID: parseInt('4000', 8),  // set UID on execution\n  TSGID: parseInt('2000', 8),  // set GID on execution\n  TSVTX: parseInt('1000', 8),  // reserved\n\n  // file permissions\n  TUREAD:  parseInt('0400', 8),  // read by owner\n  TUWRITE: parseInt('0200', 8),  // write by owner\n  TUEXEC:  parseInt('0100', 8),  // execute/search by owner\n  TGREAD:  parseInt('0040', 8),  // read by group\n  TGWRITE: parseInt('0020', 8),  // write by group\n  TGEXEC:  parseInt('0010', 8),  // execute/search by group\n  TOREAD:  parseInt('0004', 8),  // read by other\n  TOWRITE: parseInt('0002', 8),  // write by other\n  TOEXEC:  parseInt('0001', 8),   // execute/search by other\n\n  TPERMALL:  parseInt('0777', 8),   // rwxrwxrwx\n  TPERMMASK: parseInt('0777', 8)    // permissions bitmask\n\n  /* eslint-enable key-spacing */\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/constants.js\n// module id = 2\n// module chunks = 0","'use strict';\n\nvar constants = require('./constants');\nvar utils = require('./utils');\nvar types = require('./types');\n\nfunction headerSize(file) {\n  // header has fixed size\n  return types.recordSize;\n}\n\nfunction dataSize(file) {\n  // align to record boundary\n  return Math.ceil(file.data.length / types.recordSize) * types.recordSize;\n}\n\nfunction allocateBuffer(files) {\n  var totalSize = 0;\n\n  // Calculate space that will be used by each file\n  files.forEach(function(file) {\n    totalSize += headerSize(file) + dataSize(file);\n  });\n\n  // TAR must end with two empty records\n  totalSize += types.recordSize * 2;\n\n  // Array SHOULD be initialized with zeros:\n  // from TypedArray constructor docs:\n  // > When creating a TypedArray instance (i.e. instance of Int8Array\n  // > or similar), an array buffer is created internally\n  // from ArrayBuffer constructor docs:\n  // > A new ArrayBuffer object of the specified size.\n  // > Its contents are initialized to 0.\n  return new Uint8Array(totalSize);\n}\n\nfunction writeHeader(buffer, file, offset) {\n  offset = parseInt(offset) || 0;\n\n  var currentOffset = offset;\n  types.posixHeader.forEach(function(field) {\n    var value = field[3](file, field);\n    var length = value.length;\n    for (var i = 0; i < length; i += 1) {\n      buffer[currentOffset + i] = value.charCodeAt(i) & 0xFF;\n    }\n    currentOffset += field[1];  // move to the next field\n  });\n\n  var field = utils.find(types.posixHeader, function(field) {\n    return field[0] == 'checksum';\n  });\n\n  if (field) {\n    // Patch checksum field\n    var checksum = types.calculateChecksum(buffer, offset, true);\n    var value = types.formatTarNumber(checksum, field[1] - 2) +\n      constants.NULL_CHAR + ' ';\n    currentOffset = offset + field[2];\n    for (var i = 0; i < value.length; i += 1) {\n      // put bytes\n      buffer[currentOffset] = value.charCodeAt(i) & 0xFF;\n      currentOffset++;\n    }\n  }\n\n  return offset + headerSize(file);\n}\n\nfunction writeData(buffer, file, offset) {\n  offset = parseInt(offset, 10) || 0;\n  buffer.set(file.data, offset);\n  return offset + dataSize(file);\n}\n\nfunction tar(files) {\n  files = utils.map(files, function(file) {\n    return utils.extend({}, file, {\n      data: utils.toUint8Array(file.data)\n    });\n  });\n\n  var buffer = allocateBuffer(files);\n\n  var offset = 0;\n  files.forEach(function(file) {\n    offset = writeHeader(buffer, file, offset);\n    offset = writeData(buffer, file, offset);\n  });\n\n  return buffer;\n}\n\nmodule.exports.tar = tar;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/tar.js\n// module id = 3\n// module chunks = 0","'use strict';\n\nvar utils = require('./utils');\nvar constants = require('./constants');\n\nvar recordSize = 512;\nvar defaultFileMode = constants.TPERMALL;  // rwxrwxrwx\nvar defaultUid = 0;  // root\nvar defaultGid = 0;  // root\n\n/*\n struct posix_header {           // byte offset\n char name[100];               //   0\n char mode[8];                 // 100\n char uid[8];                  // 108\n char gid[8];                  // 116\n char size[12];                // 124\n char mtime[12];               // 136\n char chksum[8];               // 148\n char typeflag;                // 156\n char linkname[100];           // 157\n char magic[6];                // 257\n char version[2];              // 263\n char uname[32];               // 265\n char gname[32];               // 297\n char devmajor[8];             // 329\n char devminor[8];             // 337\n char prefix[131];             // 345\n char atime[12];               // 476\n char ctime[12];               // 488\n };\n */\n\nvar posixHeader = [\n  // <field name>, <size>, <offset>, <used>, <format>, <parse>, [ <check> ]\n  ['name', 100, 0, function(file, field) {\n    return formatTarString(file[field[0]], field[1]);\n  }, function(buffer, offset, field) {\n    return parseTarString(buffer.slice(offset, offset + field[1]));\n  }],\n  ['mode', 8, 100, function(file, field) {\n    var mode = file[field[0]] || defaultFileMode;\n    mode = mode & constants.TPERMMASK;\n    return formatTarNumber(mode, field[1], defaultFileMode);\n  }, function(buffer, offset, field) {\n    var result = parseTarNumber(buffer.slice(offset, offset + field[1]));\n    result &= constants.TPERMMASK;\n    return result;\n  }],\n  ['uid', 8, 108, function(file, field) {\n    return formatTarNumber(file[field[0]], field[1], defaultUid);\n  }, function(buffer, offset, field) {\n    return parseTarNumber(buffer.slice(offset, offset + field[1]));\n  }],\n  ['gid', 8, 116, function(file, field) {\n    return formatTarNumber(file[field[0]], field[1], defaultGid);\n  }, function(buffer, offset, field) {\n    return parseTarNumber(buffer.slice(offset, offset + field[1]));\n  }],\n  ['size', 12, 124, function(file, field) {\n    return formatTarNumber(file.data.length, field[1]);\n  }, function(buffer, offset, field) {\n    return parseTarNumber(buffer.slice(offset, offset + field[1]));\n  }],\n  ['modifyTime', 12, 136, function(file, field) {\n    return formatTarDateTime(file[field[0]], field[1]);\n  }, function(buffer, offset, field) {\n    return parseTarDateTime(buffer.slice(offset, offset + field[1]));\n  }],\n  ['checksum', 8, 148, function(file, field) {\n    return '        ';  // placeholder\n  }, function(buffer, offset, field) {\n    return parseTarNumber(buffer.slice(offset, offset + field[1]));\n  }],\n  ['type', 1, 156, function(file, field) {\n    // get last octal digit; 0 - regular file\n    return '' + ((parseInt(file[field[0]], 10) || 0) % 8);\n  }, function(buffer, offset, field) {\n    return (parseInt(String.fromCharCode(buffer[offset]), 10) || 0) % 8;\n  }],\n  ['linkName', 100, 157, function(file, field) {\n    return '';  // only regular files are supported\n  }, function(buffer, offset, field) {\n    return parseTarString(buffer.slice(offset, offset + field[1]));\n  }],\n  ['ustar', 8, 257, function(file, field) {\n    return constants.TMAGIC;  // magic + version\n  }, function(buffer, offset, field) {\n    return fixUstarMagic(\n      parseTarString(buffer.slice(offset, offset + field[1]), true)\n    );\n  }, function(file, field) {\n    return (file[field[0]] == constants.TMAGIC) ||\n      (file[field[0]] == constants.OLDGNU_MAGIC);\n  }],\n  ['owner', 32, 265, function(file, field) {\n    return formatTarString(file[field[0]], field[1]);\n  }, function(buffer, offset, field) {\n    return parseTarString(buffer.slice(offset, offset + field[1]));\n  }],\n  ['group', 32, 297, function(file, field) {\n    return formatTarString(file[field[0]], field[1]);\n  }, function(buffer, offset, field) {\n    return parseTarString(buffer.slice(offset, offset + field[1]));\n  }],\n  ['majorNumber', 8, 329, function(file, field) {\n    return '';  // only regular files are supported\n  }, function(buffer, offset, field) {\n    return parseTarNumber(buffer.slice(offset, offset + field[1]));\n  }],\n  ['minorNumber', 8, 337, function(file, field) {\n    return '';  // only regular files are supported\n  }, function(buffer, offset, field) {\n    return parseTarNumber(buffer.slice(offset, offset + field[1]));\n  }],\n  ['prefix', 131, 345, function(file, field) {\n    return formatTarString(file[field[0]], field[1]);\n  }, function(buffer, offset, field) {\n    return parseTarString(buffer.slice(offset, offset + field[1]));\n  }],\n  ['accessTime', 12, 476, function(file, field) {\n    return formatTarDateTime(file[field[0]], field[1]);\n  }, function(buffer, offset, field) {\n    return parseTarDateTime(buffer.slice(offset, offset + field[1]));\n  }],\n  ['createTime', 12, 488, function(file, field) {\n    return formatTarDateTime(file[field[0]], field[1]);\n  }, function(buffer, offset, field) {\n    return parseTarDateTime(buffer.slice(offset, offset + field[1]));\n  }]\n];\n\nvar effectiveHeaderSize = (function(header) {\n  var last = header[header.length - 1];\n  return last[2] + last[1];  // offset + size\n})(posixHeader);\n\nfunction fixUstarMagic(value) {\n  if (value.length == 8) {\n    var chars = value.split('');\n\n    if (chars[5] == constants.NULL_CHAR) {\n      // TMAGIC ?\n      if ((chars[6] == ' ') || (chars[6] == constants.NULL_CHAR)) {\n        chars[6] = '0';\n      }\n      if ((chars[7] == ' ') || (chars[7] == constants.NULL_CHAR)) {\n        chars[7] = '0';\n      }\n      chars = chars.join('');\n      return chars == constants.TMAGIC ? chars : value;\n    } else if (chars[7] == constants.NULL_CHAR) {\n      // OLDGNU_MAGIC ?\n      if (chars[5] == constants.NULL_CHAR) {\n        chars[5] = ' ';\n      }\n      if (chars[6] == constants.NULL_CHAR) {\n        chars[6] = ' ';\n      }\n      return chars == constants.OLDGNU_MAGIC ? chars : value;\n    }\n  }\n  return value;\n}\n\nfunction formatTarString(value, length) {\n  length -= 1;  // preserve space for trailing null-char\n  if (utils.isUndefined(value)) {\n    value = '';\n  }\n  value = ('' + value).substr(0, length);\n  return value + constants.NULL_CHAR;\n}\n\nfunction formatTarNumber(value, length, defaultValue) {\n  defaultValue = parseInt(defaultValue) || 0;\n  length -= 1;  // preserve space for trailing null-char\n  value = (parseInt(value) || defaultValue)\n    .toString(8).substr(-length, length);\n  while (value.length < length) {\n    value = '0' + value;\n  }\n  return value + constants.NULL_CHAR;\n}\n\nfunction formatTarDateTime(value, length) {\n  if (utils.isDateTime(value)) {\n    value = Math.floor(1 * value / 1000);\n  } else {\n    value = parseInt(value, 10);\n    if (isFinite(value)) {\n      if (value <= 0) {\n        return '';\n      }\n    } else {\n      value = Math.floor(1 * new Date() / 1000);\n    }\n  }\n  return formatTarNumber(value, length, 0);\n}\n\nfunction parseTarString(bytes, returnUnprocessed) {\n  var result = String.fromCharCode.apply(null, bytes);\n  if (returnUnprocessed) {\n    return result;\n  }\n  var index = result.indexOf(constants.NULL_CHAR);\n  return index >= 0 ? result.substr(0, index) : result;\n}\n\nfunction parseTarNumber(bytes) {\n  var result = String.fromCharCode.apply(null, bytes);\n  return parseInt(result.replace(/^0+$/g, ''), 8) || 0;\n}\n\nfunction parseTarDateTime(bytes) {\n  if ((bytes.length == 0) || (bytes[0] == 0)) {\n    return null;\n  }\n  return new Date(1000 * parseTarNumber(bytes));\n}\n\nfunction calculateChecksum(buffer, offset, skipChecksum) {\n  var from = parseInt(offset, 10) || 0;\n  var to = Math.min(from + effectiveHeaderSize, buffer.length);\n  var result = 0;\n\n  // When calculating checksum, `checksum` field should be\n  // threat as filled with space char (byte 32)\n  var skipFrom = 0;\n  var skipTo = 0;\n  if (skipChecksum) {\n    posixHeader.every(function(field) {\n      if (field[0] == 'checksum') {\n        skipFrom = from + field[2];\n        skipTo = skipFrom + field[1];\n        return false;\n      }\n      return true;\n    });\n  }\n\n  var whitespace = ' '.charCodeAt(0);\n  for (var i = from; i < to; i++) {\n    // 262144 = 8^6 - 6 octal digits - maximum possible value for checksum;\n    // wrap to avoid numeric overflow\n    var byte = (i >= skipFrom) && (i < skipTo) ? whitespace : buffer[i];\n    result = (result + byte) % 262144;\n  }\n  return result;\n}\n\nmodule.exports.recordSize = recordSize;\nmodule.exports.defaultFileMode = defaultFileMode;\nmodule.exports.defaultUid = defaultUid;\nmodule.exports.defaultGid = defaultGid;\nmodule.exports.posixHeader = posixHeader;\nmodule.exports.effectiveHeaderSize = effectiveHeaderSize;\n\nmodule.exports.calculateChecksum = calculateChecksum;\nmodule.exports.formatTarString = formatTarString;\nmodule.exports.formatTarNumber = formatTarNumber;\nmodule.exports.formatTarDateTime = formatTarDateTime;\nmodule.exports.parseTarString = parseTarString;\nmodule.exports.parseTarNumber = parseTarNumber;\nmodule.exports.parseTarDateTime = parseTarDateTime;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/types.js\n// module id = 4\n// module chunks = 0","'use strict';\n\nvar constants = require('./constants');\nvar utils = require('./utils');\nvar types = require('./types');\n\nvar defaultOptions = {\n  extractData: true,\n  checkHeader: true,\n  checkChecksum: true,\n  checkFileSize: true\n};\n\nvar excludeFields = {\n  size: true,\n  checksum: true,\n  ustar: true\n};\n\nvar messages = {\n  unexpectedEndOfFile: 'Unexpected end of file.',\n  fileCorrupted: 'File is corrupted.',\n  checksumCheckFailed: 'Checksum check failed.'\n};\n\nfunction headerSize(header) {\n  // header has fixed size\n  return types.recordSize;\n}\n\nfunction dataSize(size) {\n  // align to record boundary\n  return Math.ceil(size / types.recordSize) * types.recordSize;\n}\n\nfunction isEndOfFile(buffer, offset) {\n  var from = offset;\n  var to = Math.min(buffer.length, offset + types.recordSize * 2);\n  for (var i = from; i < to; i++) {\n    if (buffer[i] != 0) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction readHeader(buffer, offset, options) {\n  if (buffer.length - offset < types.recordSize) {\n    if (options.checkFileSize) {\n      throw new Error(messages.unexpectedEndOfFile);\n    }\n    return null;\n  }\n\n  offset = parseInt(offset) || 0;\n\n  var result = {};\n  var currentOffset = offset;\n  types.posixHeader.forEach(function(field) {\n    result[field[0]] = field[4](buffer, currentOffset, field);\n    currentOffset += field[1];\n  });\n\n  if (result.type != 0) {  // only regular files can have data\n    result.size = 0;\n  }\n\n  if (options.checkHeader) {\n    types.posixHeader.forEach(function(field) {\n      if (utils.isFunction(field[5]) && !field[5](result, field)) {\n        var error = new Error(messages.fileCorrupted);\n        error.data = {\n          offset: offset + field[2],\n          field: field[0]\n        };\n        throw error;\n      }\n    });\n  }\n\n  if (options.checkChecksum) {\n    var checksum = types.calculateChecksum(buffer, offset, true);\n    if (checksum != result.checksum) {\n      var error = new Error(messages.checksumCheckFailed);\n      error.data = {\n        offset: offset,\n        header: result,\n        checksum: checksum\n      };\n      throw error;\n    }\n  }\n\n  return result;\n}\n\nfunction readData(buffer, offset, header, options) {\n  if (!options.extractData) {\n    return null;\n  }\n\n  if (header.size <= 0) {\n    return new Uint8Array();\n  }\n  return buffer.slice(offset, offset + header.size);\n}\n\nfunction createFile(header, data) {\n  var result = {};\n  types.posixHeader.forEach(function(field) {\n    var name = field[0];\n    if (!excludeFields[name]) {\n      result[name] = header[name];\n    }\n  });\n\n  result.isOldGNUFormat = header.ustar == constants.OLDGNU_MAGIC;\n\n  if (data) {\n    result.data = data;\n  }\n\n  return result;\n}\n\nfunction untar(buffer, options) {\n  options = utils.extend({}, defaultOptions, options);\n\n  var result = [];\n  var offset = 0;\n  var size = buffer.length;\n\n  while (size - offset >= types.recordSize) {\n    buffer = utils.toUint8Array(buffer);\n    var header = readHeader(buffer, offset, options);\n    if (!header) {\n      break;\n    }\n    offset += headerSize(header);\n\n    var data = readData(buffer, offset, header, options);\n    result.push(createFile(header, data));\n    offset += dataSize(header.size);\n\n    if (isEndOfFile(buffer, offset)) {\n      break;\n    }\n  }\n\n  return result;\n}\n\nmodule.exports.untar = untar;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/untar.js\n// module id = 5\n// module chunks = 0"],"sourceRoot":""}